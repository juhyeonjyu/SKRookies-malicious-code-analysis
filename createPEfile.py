from struct import pack
import os

def create_valid_pe_file(output_filename):
    # --- DOS 부분 ---
    dos_header = bytearray(64)
    dos_header[0:2] = b'MZ'  # DOS 시그니처

    dos_stub = b"This is a valid PE file generated by Python!\r\n$"
    
    # 동적으로 NT 헤더 오프셋 계산
    nt_header_offset = len(dos_header) + len(dos_stub)
    dos_header[60:64] = pack('<I', nt_header_offset)

    # --- NT 헤더 (시그니처 + 파일 헤더) ---
    nt_headers = bytearray(24)
    nt_headers[0:4] = b'PE\x00\x00'  # PE 시그니처
    nt_headers[4:6] = pack('<H', 0x014C)  # Machine: Intel 386
    nt_headers[6:8] = pack('<H', 3)       # NumberOfSections: 3
    nt_headers[20:22] = pack('<H', 224)   # SizeOfOptionalHeader
    nt_headers[22:24] = pack('<H', 0x0102) # Characteristics: Executable

    # --- 옵셔널 헤더 ---
    optional_header = bytearray(224) # 옵셔널 헤더 + 데이터 디렉토리
    optional_header[0:2] = pack('<H', 0x010B)  # Magic: PE32
    optional_header[28:32] = pack('<I', 0x1000) # AddressOfEntryPoint
    optional_header[32:36] = pack('<I', 0x1000) # BaseOfCode
    optional_header[52:56] = pack('<I', 0x400000) # ImageBase
    optional_header[56:60] = pack('<I', 0x1000)   # SectionAlignment
    optional_header[60:64] = pack('<I', 0x200)    # FileAlignment
    optional_header[88:92] = pack('<I', 0x4000)   # SizeOfImage
    # (다른 필수 필드들은 0으로 채워짐)

    # --- 섹션 헤더 ---
    section_headers = bytearray(3 * 40)
    file_alignment = 0x200
    
    # 헤더들의 총 길이 계산 (이 위치 다음에 첫 섹션 데이터가 옴)
    header_size = nt_header_offset + len(nt_headers) + len(optional_header) + len(section_headers)
    
    # 파일 정렬에 맞게 첫 섹션 데이터의 파일 오프셋 계산
    first_section_offset = (header_size + file_alignment - 1) // file_alignment * file_alignment

    # 섹션 1: .text
    section_headers[0:8] = b'.text\x00\x00\x00'
    section_headers[12:16] = pack('<I', 0x1000)
    section_headers[20:24] = pack('<I', first_section_offset)
    section_headers[36:40] = pack('<I', 0x60000020)

    # 섹션 2: .data
    section_headers[40:48] = b'.data\x00\x00\x00'
    section_headers[52:56] = pack('<I', 0x2000)
    section_headers[60:64] = pack('<I', first_section_offset + 0x200)
    section_headers[76:80] = pack('<I', 0xC0000040)

    # 섹션 3: .rsrc
    section_headers[80:88] = b'.rsrc\x00\x00\x00'
    section_headers[92:96] = pack('<I', 0x3000)
    section_headers[100:104] = pack('<I', first_section_offset + 0x400)
    section_headers[116:120] = pack('<I', 0x40000040)

    # --- 모든 부분 결합 및 파일 쓰기 ---
    # 1. 헤더 부분 먼저 구성
    pe_data = dos_header + dos_stub + nt_headers + optional_header + section_headers

    # 2. 섹션 데이터를 위한 공간(padding) 추가
    # 현재 데이터 크기와 첫 섹션이 시작되어야 할 위치의 차이만큼 0으로 채움
    padding_size = first_section_offset - len(pe_data)
    pe_data += bytearray(padding_size)

    # (빈 섹션들이지만 파일 정렬에 맞게 공간은 만들어 줌)
    pe_data += bytearray(3 * file_alignment)
    
    with open(output_filename, 'wb') as f:
        f.write(pe_data)

    file_size = os.path.getsize(output_filename)
    print(f"생성된 PE 파일: {output_filename}, 크기: {file_size} 바이트")
    if file_size < 5120:
        print("파일 크기가 5KB 미만 요구 사항을 충족했습니다.")
    else:
        print("경고: 파일 크기가 5KB를 초과했습니다.")

if __name__ == "__main__":
    create_valid_pe_file("pefile.exe")